<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Skyworks Concourse — Isometric JS Game</title>
<style>
  :root{
    --bg1:#0b1016; --bg2:#0f1620; --ink:#cfe3ee; --muted:#95a9b8;
    --accent:#39ffb8; --warn:#ffd45e; --danger:#ff6b6b;
    --panel:#0b131a; --panel2:#0a0f14; --line:#1e2a37;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
  #root{display:grid;grid-template-rows:auto 1fr}
  header{display:flex;align-items:center;gap:16px;padding:10px 14px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,var(--panel),var(--panel2))}
  .brand{font-weight:700;letter-spacing:.08em;color:#e2f7f0}
  .stat{margin-left:auto;color:#a4bac7}
  .stat b{color:#bdf5df}
  main{position:relative}
  #c{display:block;margin:0 auto;image-rendering:pixelated}

  /* Quest log */
  aside#ql{position:absolute;top:12px;right:12px;width:320px;max-height:80vh;overflow:auto;background:rgba(10,15,22,.9);border:1px solid var(--line);border-radius:8px;box-shadow:0 6px 28px rgba(0,0,0,.35);padding:12px}
  aside h2{font-size:12px;text-transform:uppercase;letter-spacing:.12em;color:#a9cbd8;opacity:.95;margin-bottom:6px}
  .quest{border:1px solid var(--line);border-radius:8px;padding:10px;background:linear-gradient(180deg,#0b1218,#0a1015);margin-bottom:8px}
  .quest h3{font-size:14px;margin-bottom:6px}
  .tag{font-size:11px;color:#9eecc6;background:rgba(57,255,184,.1);border:1px solid rgba(57,255,184,.25);padding:1px 6px;border-radius:999px;margin-left:6px}
  .q-obj{font-size:13px;color:#a9b8c3;padding-left:12px;position:relative;margin:3px 0}
  .q-obj::before{content:"•";position:absolute;left:0;top:0;color:#6b90a6}
  .q-done{color:#6fe49f;text-decoration:line-through;opacity:.85}
  .hidden{display:none!important}

  /* Help chip */
  #help{position:absolute;left:12px;top:12px;max-width:460px;background:rgba(9,14,20,.85);border:1px solid var(--line);border-radius:8px;padding:10px}
  #help h2{font-size:12px;text-transform:uppercase;letter-spacing:.12em;color:#a9cbd8;margin-bottom:5px}
  .kbd{display:inline-block;border:1px solid #2a3948;background:#0b1319;color:#b7c8d1;padding:1px 6px;border-radius:4px;box-shadow:0 1px 0 #000 inset;font-size:12px}

  /* Toasts */
  #toasts{position:absolute;left:50%;transform:translateX(-50%);bottom:70px;display:flex;flex-direction:column;gap:8px;pointer-events:none}
  .toast{background:rgba(7,12,18,.92);border:1px solid var(--line);padding:8px 10px;border-radius:6px;min-width:220px;text-align:center}
  .accent{color:#39ffb8} .danger{color:#ff6b6b} .warn{color:#ffd45e}

  /* Overlays */
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:20}
  .panel{min-width:320px;max-width:520px;background:linear-gradient(180deg,#0c141c,#0a1015);border:1px solid var(--line);border-radius:10px;box-shadow:0 10px 34px rgba(0,0,0,.45);padding:18px;text-align:center}
  .panel h1{font-size:22px;margin-bottom:12px;color:#e7f6ff}
  .panel p{color:#b7c6cf;margin-bottom:14px}
  .btn{display:inline-block;margin:4px;padding:8px 12px;border-radius:6px;border:1px solid #2b3c4e;background:#0b151c;color:#d9e6ee;cursor:pointer}
  .btn.primary{border-color:#1a9b74;background:#0a201a;color:#baf7e2}

  /* Damage flash */
  #flash{position:absolute;inset:0;background:radial-gradient(circle at 50% 50%, rgba(255,0,0,.25), rgba(255,0,0,0) 60%);opacity:0;pointer-events:none;transition:opacity .12s ease;z-index:10}

  /* Music pill */
  #music{position:absolute;bottom:12px;left:12px;background:rgba(9,14,20,.85);border:1px solid var(--line);border-radius:18px;padding:6px 10px;color:#b6c4cf;cursor:pointer;user-select:none}
</style>
</head>
<body>
<div id="root">
  <header>
    <div class="brand">Skyworks Concourse</div>
    <div class="stat">HP: <b id="hp">10</b> • FPS: <b id="fps">60</b></div>
  </header>
  <main>
    <canvas id="c" width="1280" height="720" aria-label="Game canvas"></canvas>

    <div id="help">
      <h2>Controls</h2>
      <p>
        <span class="kbd">WASD</span>/<span class="kbd">Arrows</span> move •
        <span class="kbd">E</span> interact •
        <span class="kbd">Space</span> attack •
        <span class="kbd">Q</span> quests •
        <span class="kbd">M</span> music on/off
      </p>
    </div>

    <aside id="ql">
      <h2>Quests</h2>
      <div id="quests"></div>
    </aside>

    <div id="toasts"></div>
    <div id="flash"></div>
    <div id="music">Music: Off</div>

    <!-- Overlays -->
    <div id="overlayGameOver" class="overlay hidden">
      <div class="panel">
        <h1>Systems Overload</h1>
        <p>Your suit shut down after critical damage. The concourse hums without you.</p>
        <button class="btn primary" id="btnRetry">Retry</button>
      </div>
    </div>
    <div id="overlayWin" class="overlay hidden">
      <div class="panel">
        <h1>Departure Achieved</h1>
        <p>All objectives completed. Clearance granted for the upper decks. Well done, courier.</p>
        <button class="btn primary" id="btnPlayAgain">Play Again</button>
      </div>
    </div>
  </main>
</div>

<script>
/* ===========================
   Utilities
=========================== */
function sfc32(a,b,c,d){return function(){a|=0;b|=0;c|=0;d|=0;var t=(a+b|0)+d|0;d=d+1|0;a=b^(b>>>9);b=c+(c<<3)|0;c=(c<<21|c>>>11);c=c+t|0;return (t>>>0)/4294967296}}
function hashStrToSeed(s){let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i);h=(h*16777619)>>>0} return [h,h^0x9e3779b9,h^0x7f4a7c15,h^0x85ebca6b].map(x=>x>>>0)}
function clamp(v,min,max){return Math.max(min,Math.min(max,v))}
function randRange(r,min,max){return min+(max-min)*r()}
function dist(x1,y1,x2,y2){return Math.hypot(x2-x1,y2-y1)}
function makeNoise(rng, size=64, octaves=3){
  const base=new Float32Array(size*size); for(let i=0;i<base.length;i++) base[i]=rng()
  function sample(x,y){x=(x%size+size)%size;y=(y%size+size)%size;return base[(y|0)*size+(x|0)]}
  return function(x,y){
    let v=0, amp=1, freq=1, norm=0
    for(let o=0;o<octaves;o++){
      const sx=(x*freq)%size, sy=(y*freq)%size
      const x0=sx|0,y0=sy|0,x1=(x0+1)%size,y1=(y0+1)%size
      const tx=sx-x0, ty=sy-y0
      const a=sample(x0,y0), b=sample(x1,y0), c=sample(x0,y1), d=sample(x1,y1)
      const u=(1-Math.cos(tx*Math.PI))*0.5, v2=(1-Math.cos(ty*Math.PI))*0.5
      const i1=a*(1-u)+b*u, i2=c*(1-u)+d*u
      v += (i1*(1-v2)+i2*v2) * amp
      norm += amp; amp*=0.5; freq*=2
    } return v/norm
  }
}

/* ===========================
   Engine
=========================== */
class Input{
  constructor(){this.keys=new Set(); this.just=new Set();
    addEventListener('keydown',e=>{ if(!this.keys.has(e.code)) this.just.add(e.code); this.keys.add(e.code);
      if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault() })
    addEventListener('keyup',e=>{ this.keys.delete(e.code); this.just.delete(e.code) })
  }
  down(k){return this.keys.has(k)} pressed(k){const p=this.just.has(k); if(p) this.just.delete(k); return p}
}
class Camera{constructor(){this.x=0;this.y=0;this.zoom=1} centerOn(sx,sy,vw,vh){this.x=sx - vw/2; this.y=sy - vh/2}}
class Engine{
  constructor(canvas){this.c=canvas; this.g=canvas.getContext('2d'); this.input=new Input(); this.cam=new Camera();
    this.updatables=[]; this.renderables=[]; this.fps=60; this._frames=0; this._fpst=0; this.last=0; this._run=false;
    this.loop=(t)=>{ if(!this._run) return; if(!this.last) this.last=t; const dt=Math.min(0.05,(t-this.last)/1000); this.last=t;
      this._frames++; this._fpst+=dt; if(this._fpst>=1){this.fps=this._frames; this._frames=0; this._fpst=0; document.getElementById('fps').textContent=this.fps}
      for(const u of this.updatables) u.update?.(dt,this)
      this.g.setTransform(1,0,0,1,0,0); this.g.clearRect(0,0,this.c.width,this.c.height)
      for(const r of this.renderables) r.render?.(this.g,this)
      requestAnimationFrame(this.loop)}
  }
  start(){this._run=true; requestAnimationFrame(this.loop)} stop(){this._run=false}
}

/* ===========================
   Iso projection
=========================== */
const TILE_W=64, TILE_H=32
function isoToScreen(ix,iy,iz=0){return {x:(ix-iy)*(TILE_W/2), y:(ix+iy)*(TILE_H/2) - iz*24}}
function screenToIso(sx,sy){return {x:(sx/(TILE_W/2)+sy/(TILE_H/2))/2, y:(sy/(TILE_H/2)-sx/(TILE_W/2))/2}}

/* ===========================
   Procedural textures
=========================== */
function makeTileFactory(seed){
  const rng=sfc32(...hashStrToSeed(seed+'tiles')), noise=makeNoise(rng,64,3)
  const colors={ steel:'#1e2a33', steelLo:'#0f161c', brass:'#5a4a2f', brassHi:'#8b6a33',
    glass:'#113342', glassHi:'#1a4e66', mint:'#2cffb2', circuit:'#243847', wire:'#80ffd4', rustLo:'#3c2424', wall:'#2a3238'}
  function pat(painter){const s=64, off=document.createElement('canvas'); off.width=off.height=s; const gg=off.getContext('2d'); painter(gg,s); return gg.createPattern(off,'repeat')}
  const steel=pat((gg,s)=>{gg.fillStyle=colors.steel; gg.fillRect(0,0,s,s);
    for(let y=0;y<s;y++)for(let x=0;x<s;x++){const v=noise(x*1.1,y*1.1); gg.fillStyle=`rgba(255,255,255,${v*0.06})`; gg.fillRect(x,y,1,1)}
    gg.strokeStyle=colors.steelLo; gg.lineWidth=2; gg.beginPath(); gg.moveTo(0,s/2); gg.lineTo(s,s/2); gg.stroke()})
  const brass=pat((gg,s)=>{gg.fillStyle=colors.brass; gg.fillRect(0,0,s,s); gg.strokeStyle=colors.brassHi; gg.lineWidth=1.5; for(let y=8;y<s;y+=16){gg.beginPath(); gg.moveTo(0,y); gg.lineTo(s,y); gg.stroke()}})
  const glass=pat((gg,s)=>{gg.fillStyle=colors.glass; gg.fillRect(0,0,s,s); gg.strokeStyle=colors.glassHi; gg.strokeRect(6,6,s-12,s-12)})
  const neon=pat((gg,s)=>{gg.fillStyle='#0a0f14'; gg.fillRect(0,0,s,s);
    gg.strokeStyle='#1abf83'; gg.lineWidth=1; for(let i=0;i<s;i+=8){gg.beginPath(); gg.moveTo(0,i); gg.lineTo(s,i); gg.stroke(); gg.beginPath(); gg.moveTo(i,0); gg.lineTo(i,s); gg.stroke()}
    for(let i=0;i<24;i++){gg.fillStyle=`rgba(44,255,178,${0.2+0.4*Math.random()})`; gg.fillRect((Math.random()*s)|0,(Math.random()*s)|0,1,1)}})
  const circuit=pat((gg,s)=>{gg.fillStyle=colors.circuit; gg.fillRect(0,0,s,s); gg.strokeStyle=colors.wire; gg.lineWidth=1
    for(let i=0;i<6;i++){const y=(i+1)*s/7; gg.beginPath(); gg.moveTo(0,y); gg.lineTo(s,y); gg.stroke()
      const x=(i+1)*s/7; gg.beginPath(); gg.moveTo(x,0); gg.lineTo(x,s); gg.stroke()}})
  const rust=pat((gg,s)=>{gg.fillStyle=colors.rustLo; gg.fillRect(0,0,s,s);
    for(let y=0;y<s;y++)for(let x=0;x<s;x++){const v=noise(x*1.6,y*1.6); gg.fillStyle=`rgba(${90+v*80},${60+v*40},${60+v*40},${0.16+v*0.12})`; gg.fillRect(x,y,1,1)}})
  const wall=pat((gg,s)=>{gg.fillStyle=colors.wall; gg.fillRect(0,0,s,s); gg.strokeStyle='#111'; gg.strokeRect(6,6,s-12,s-12)})
  function drawDiamond(g,sx,sy,h,face){
    const w=TILE_W, hh=TILE_H
    g.save()
    g.beginPath()
    g.moveTo(sx, sy - h)
    g.lineTo(sx + w/2, sy + hh/2 - h)
    g.lineTo(sx, sy + hh - h)
    g.lineTo(sx - w/2, sy + hh/2 - h)
    g.closePath()
    g.fillStyle=face; g.fill()
    g.fillStyle='rgba(0,0,0,0.22)'
    g.beginPath()
    g.moveTo(sx - w/2, sy + hh/2 - h)
    g.lineTo(sx - w/2, sy + hh/2)
    g.lineTo(sx, sy + hh)
    g.lineTo(sx, sy + hh - h)
    g.closePath(); g.fill()
    g.beginPath()
    g.moveTo(sx + w/2, sy + hh/2 - h)
    g.lineTo(sx + w/2, sy + hh/2)
    g.lineTo(sx, sy + hh)
    g.lineTo(sx, sy + hh - h)
    g.closePath(); g.fill()
    g.restore()
  }
  return {faces:{steel,brass,glass,neon,circuit,rust,wall}, drawDiamond}
}

/* ===========================
   World (buildings + corridors + walls)
=========================== */
class IsoMap{
  constructor(w,h,seed){this.w=w; this.h=h; this.seed=seed; this.tiles=new Array(w*h); this.discovered=new Uint8Array(w*h)
    this.rng=sfc32(...hashStrToSeed(seed+'map')); this.noise=makeNoise(this.rng,64,4); this.factory=makeTileFactory(seed)}
  idx(x,y){return y*this.w+x} inBounds(x,y){return x>=0&&y>=0&&x<this.w&&y<this.h}
  at(x,y){return this.tiles[this.idx(x,y)]}

  generate(){
    // 1) Base fill as steel, walkable
    for(let y=0;y<this.h;y++)for(let x=0;x<this.w;x++){
      this.tiles[this.idx(x,y)]={x,y,type:'steel',height:0,walkable:true}
    }
    // 2) Place themed buildings (rectangles) and corridors
    const rooms=[]
    const roomCount=6
    const rng=this.rng
    function rect(x,y,w,h){return {x,y,w,h}}
    // random rooms with bounds
    for(let i=0;i<roomCount;i++){
      const rw = 6 + (rng()*6)|0
      const rh = 5 + (rng()*6)|0
      const rx = 2 + (rng()*(32-rw-4))|0
      const ry = 2 + (rng()*(32-rh-4))|0
      rooms.push(rect(rx,ry,rw,rh))
    }
    // carve rooms: interior themed floors, perimeter walls (non-walkable)
    for(const r of rooms){
      for(let y=r.y; y<r.y+r.h; y++){
        for(let x=r.x; x<r.x+r.w; x++){
          const t=this.at(x,y)
          // perimeter walls
          if(x===r.x || y===r.y || x===r.x+r.w-1 || y===r.y+r.h-1){
            t.type='wall'; t.walkable=false; t.height=1
          }else{
            // interior themed floors with variety
            const n=this.noise(x*0.25,y*0.25)
            t.type = n>0.75?'glass' : n>0.55?'brass' : n>0.35?'circuit' : n>0.2?'rust':'steel'
            t.walkable=true
          }
        }
      }
      // carve a door in each room wall
      const doorSide=((rng()*4)|0)
      let dx=r.x+1+(rng()*(r.w-2)|0), dy=r.y
      if(doorSide===0){dx=r.x+1+(rng()*(r.w-2)|0); dy=r.y}         // top
      if(doorSide===1){dx=r.x+1+(rng()*(r.w-2)|0); dy=r.y+r.h-1}   // bottom
      if(doorSide===2){dx=r.x; dy=r.y+1+(rng()*(r.h-2)|0)}         // left
      if(doorSide===3){dx=r.x+r.w-1; dy=r.y+1+(rng()*(r.h-2)|0)}   // right
      const dt=this.at(dx,dy); dt.type='steel'; dt.walkable=true; dt.height=0; // doorway
    }
    // 3) Corridors connecting room centers with L-shapes (steel)
    const centers=rooms.map(r=>({x:(r.x+r.x+r.w-1)/2|0, y:(r.y+r.y+r.h-1)/2|0}))
    centers.sort((a,b)=>a.x+b.y-(b.x+a.y))
    for(let i=0;i<centers.length-1;i++){
      const a=centers[i], b=centers[i+1]
      for(let x=Math.min(a.x,b.x); x<=Math.max(a.x,b.x); x++){ const t=this.at(x,a.y); t.type='steel'; t.walkable=true }
      for(let y=Math.min(a.y,b.y); y<=Math.max(a.y,b.y); y++){ const t=this.at(b.x,y); t.type='steel'; t.walkable=true }
    }
    // 4) Decorative exterior rails (walls) along edges in some places
    for(let x=0;x<this.w;x++){ const t=this.at(x,1); t.type='wall'; t.walkable=false; t.height=1 }
    for(let x=0;x<this.w;x++){ const t=this.at(x,this.h-2); t.type='wall'; t.walkable=false; t.height=1 }
  }

  reveal(cx,cy,r=3){for(let y=cy-r;y<=cy+r;y++)for(let x=cx-r;x<=cx+r;x++) if(this.inBounds(x,y)&&((x-cx)*(x-cx)+(y-cy)*(y-cy)<=r*r)) this.discovered[this.idx(x,y)]=1}
  isDiscovered(x,y){return this.discovered[this.idx(x,y)]===1}
}

/* ===========================
   Sprite factory (simple anim)
=========================== */
function makeSpriteFactory(){
  function mk(frames, paint){
    const list=[]
    for(let i=0;i<frames;i++){
      const c=document.createElement('canvas'); c.width=48; c.height=48; const g=c.getContext('2d')
      paint(g, i, frames, c.width, c.height); list.push(c)
    }
    return list
  }
  const playerFrames = mk(6,(g,i,frames,w,h)=>{
    g.clearRect(0,0,w,h); const cx=w/2, cy=h/2+6
    g.fillStyle='rgba(0,0,0,.35)'; g.beginPath(); g.ellipse(cx,cy+14,14,7,0,0,Math.PI*2); g.fill()
    const bob = Math.sin(i/frames*Math.PI*2)*2
    g.fillStyle='#1fcf90'; g.beginPath(); g.moveTo(cx,cy-18+bob); g.lineTo(cx+10,cy+bob); g.lineTo(cx,cy+18+bob); g.lineTo(cx-10,cy+bob); g.closePath(); g.fill()
    const a=0.6+0.4*Math.sin(i/frames*Math.PI*2)
    g.fillStyle=`rgba(233,255,248,${a})`; g.fillRect(cx-4,cy-8+bob,8,3)
  })
  const droneFrames = mk(8,(g,i,frames,w,h)=>{
    g.clearRect(0,0,w,h); const cx=w/2, cy=h/2+4
    g.fillStyle='rgba(0,0,0,.3)'; g.beginPath(); g.ellipse(cx,cy+14,12,6,0,0,Math.PI*2); g.fill()
    g.fillStyle='#7cc9c2'; g.beginPath(); g.ellipse(cx,cy-4,18,12,0,0,Math.PI*2); g.fill()
    g.save(); g.translate(cx,cy-4); g.rotate((i/frames)*Math.PI*2); g.fillStyle='#354950'; g.fillRect(-18,-2,36,4); g.fillRect(-2,-18,4,36); g.restore()
    const blink = (i%frames)<1?0.2:1
    g.fillStyle=`rgba(255,105,97,${blink})`; g.fillRect(cx-2,cy-7,4,3)
  })
  const shardFrames = mk(8,(g,i,frames,w,h)=>{
    g.clearRect(0,0,w,h); const cx=w/2, cy=h/2
    const ang = (i/frames)*Math.PI*2
    g.save(); g.translate(cx,cy-6); g.rotate(ang)
    g.fillStyle='#e6fffb'; g.beginPath(); g.moveTo(0,-6); g.lineTo(5,0); g.lineTo(0,6); g.lineTo(-5,0); g.closePath(); g.fill()
    g.strokeStyle='#39ffb8'; g.stroke(); g.restore()
    g.fillStyle='rgba(0,0,0,.25)'; g.beginPath(); g.ellipse(cx,cy+10,8,4,0,0,Math.PI*2); g.fill()
  })
  return {playerFrames, droneFrames, shardFrames}
}

/* ===========================
   Entities & collisions
=========================== */
class Entity{
  constructor(kind,x,y){this.kind=kind; this.x=x; this.y=y; this.z=0; this.r=0.35; this.hp=1; this.maxHp=1; this.dead=false; this.solid=false}
  iso(){return isoToScreen(this.x,this.y,this.z)}
  update(dt,game){} render(g,game){}
}
function renderHpBar(g,x,y,hp,max){const w=24,h=4; g.fillStyle='rgba(0,0,0,.6)'; g.fillRect(x-w/2,y,w,h); g.fillStyle='#39ffb8'; g.fillRect(x-w/2,y,(w*hp/max),h); g.strokeStyle='rgba(0,0,0,.8)'; g.strokeRect(x-w/2,y,w,h)}

class Player extends Entity{
  constructor(x,y,sprites){super('player',x,y); this.r=0.34; this.speed=4.6; this.hp=10; this.maxHp=10; this.attackCd=0; this.inv={shards:0, core:true}; this.sprites=sprites; this.anim=0; this.vel={x:0,y:0}}
  update(dt,game){
    const inp=game.engine.input
    let dx=0,dy=0
    if(inp.down('KeyW')||inp.down('ArrowUp')) dy-=1
    if(inp.down('KeyS')||inp.down('ArrowDown')) dy+=1
    if(inp.down('KeyA')||inp.down('ArrowLeft')) dx-=1
    if(inp.down('KeyD')||inp.down('ArrowRight')) dx+=1
    // normalize
    if(dx||dy){const l=Math.hypot(dx,dy); dx/=l; dy/=l}
    // floor effects: speed & friction
    const t=game.map.at(this.x|0,this.y|0)
    let mult=1, friction=1
    if(t){
      if(t.type==='brass') mult=1.10
      else if(t.type==='circuit') mult=1.05
      else if(t.type==='rust') mult=0.85
      else if(t.type==='glass'){ mult=1.0; friction=0.85 } // glide
    }
    const targetVX = dx*this.speed*mult
    const targetVY = dy*this.speed*mult
    // simple acceleration/friction
    this.vel.x = this.vel.x*friction + (targetVX - this.vel.x)*0.6
    this.vel.y = this.vel.y*friction + (targetVY - this.vel.y)*0.6
    const res = game.resolveCollisions(this, this.x + this.vel.x*dt, this.y + this.vel.y*dt)
    this.x=res.x; this.y=res.y

    // attack
    if(this.attackCd>0) this.attackCd-=dt
    if(inp.pressed('Space') && this.attackCd<=0){
      this.attackCd=0.45
      let best=null, bd=999
      for(const e of game.entities) if(e.kind==='drone'&&!e.dead){
        const d=dist(this.x,this.y,e.x,e.y); if(d<bd && d<0.95){best=e; bd=d}
      }
      if(best){ best.hp-=2; game.fxLabel(best,'-2','#ff7b7b'); if(best.hp<=0){best.dead=true; game.onEnemyDown(best)} }
      else game.toast('No target in range.')
    }
    this.anim=(this.anim + dt*8)%this.sprites.playerFrames.length
    game.map.reveal(this.x|0,this.y|0,4); game.events.onMove?.(this)
  }
  render(g){
    const {x,y}=this.iso()
    const frame=this.sprites.playerFrames[this.anim|0]
    g.drawImage(frame, x-24, y-46)
    renderHpBar(g,x,y-30,this.hp,this.maxHp)
  }
}
class Drone extends Entity{
  constructor(x,y,sprites){super('drone',x,y); this.r=0.32; this.speed=2.5; this.hp=4; this.maxHp=4; this.t=0; this.dir=0; this.cd=0; this.sprites=sprites; this.anim=0}
  update(dt,game){
    if(this.dead) return
    this.t+=dt; if(this.cd>0) this.cd-=dt
    const p=game.player
    const d=dist(this.x,this.y,p.x,p.y)
    let dx=0,dy=0
    if(d<5){dx = Math.sign(p.x-this.x); dy=Math.sign(p.y-this.y)}
    else { if(this.t>1.4){ this.t=0; this.dir=((game.rng()*8)|0) }
      const dirs=[[1,0],[0,1],[-1,0],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]
      dx=dirs[this.dir][0]; dy=dirs[this.dir][1]
    }
    // floor effects for drones too (slight)
    const t=game.map.at(this.x|0,this.y|0); let mult=1
    if(t){ if(t.type==='brass') mult=1.08; else if(t.type==='rust') mult=0.9; else if(t.type==='circuit') mult=1.03 }
    const res=game.resolveCollisions(this, this.x+dx*this.speed*mult*dt, this.y+dy*this.speed*mult*dt, true)
    this.x=res.x; this.y=res.y
    if(d<0.8 && this.cd<=0 && !game.gameOver){ this.cd=1.0; game.damagePlayer(1, this) }
    this.anim=(this.anim + dt*10)%this.sprites.droneFrames.length
  }
  render(g){
    const {x,y}=this.iso()
    const frame=this.sprites.droneFrames[this.anim|0]
    g.drawImage(frame, x-24, y-44)
    renderHpBar(g,x,y-28,this.hp,this.maxHp)
  }
}
class NPC extends Entity{
  constructor(name,x,y,lines){super('npc',x,y); this.name=name; this.lines=lines; this.solid=true; this.r=0.33}
  talk(game){game.toast(`${this.name}: ${this.lines[(game.rng()*this.lines.length)|0]}`)}
  render(g){const {x,y}=this.iso(); g.fillStyle='#e8cd8c'; g.fillRect(x-3,y-14,6,14); g.fillStyle='#3a2a16'; g.fillRect(x-3,y-18,6,4)}
}
class Terminal extends Entity{
  constructor(id,x,y,onUse){super('terminal',x,y); this.id=id; this.onUse=onUse; this.solid=true; this.r=0.3}
  render(g){const {x,y}=this.iso(); g.fillStyle='#0a0f14'; g.fillRect(x-6,y-16,12,16); g.fillStyle='rgba(57,255,184,.85)'; g.fillRect(x-5,y-12,10,8); g.fillStyle='rgba(57,255,184,.18)'; g.beginPath(); g.arc(x,y-12,14,0,Math.PI*2); g.fill()}
}
class SwitchPlate extends Entity{
  constructor(id,x,y,onToggle){super('switch',x,y); this.id=id; this.on=0; this.onToggle=onToggle; this.solid=false; this.r=0.25}
  interact(game){this.on=1-this.on; game.fxLabel(this,this.on?'ON':'OFF', this.on?'#8be89e':'#aab7c0'); this.onToggle?.(this,game)}
  render(g){const {x,y}=this.iso(); g.fillStyle=this.on?'#39ffb8':'#3b5365'; g.beginPath(); g.moveTo(x,y-6); g.lineTo(x+10,y); g.lineTo(x,y+6); g.lineTo(x-10,y); g.closePath(); g.fill()}
}
class Gate extends Entity{
  constructor(id,x,y,open=false){super('gate',x,y); this.id=id; this.open=open; this.solid=!open; this.r=0.4}
  setOpen(v){this.open=v; this.solid=!v}
  render(g){ if(this.open) return; const {x,y}=this.iso(); g.fillStyle='#8b6a33'; g.fillRect(x-3,y-26,6,26)}
}
class Pickup extends Entity{
  constructor(kind,x,y,sprites){super('pickup',x,y); this.item=kind; this.solid=false; this.r=0.2; this.sprites=sprites; this.anim=0}
  update(dt){ this.anim=(this.anim+dt*8)%this.sprites.shardFrames.length }
  render(g){const {x,y}=this.iso(); const f=this.sprites.shardFrames[this.anim|0]; g.drawImage(f, x-24, y-40)}
}
class Crate extends Entity{
  constructor(x,y){super('crate',x,y); this.solid=true; this.r=0.38}
  render(g){const {x,y}=this.iso(); g.fillStyle='#5c4a2e'; g.fillRect(x-8,y-22,16,22); g.strokeStyle='#2f2416'; g.strokeRect(x-8,y-22,16,22)}
}

/* ===========================
   Quests
=========================== */
class Quest{
  constructor(id,title,type,objectives){this.id=id; this.title=title; this.type=type; this.objectives=objectives.map(o=>({...o,done:false})); this.done=false}
  progress(check){let changed=false; for(const o of this.objectives){ if(!o.done && check(o)){o.done=true; changed=true} } this.done=this.objectives.every(o=>o.done); return changed}
}
class QuestManager{
  constructor(onUi){this.quests=[]; this.onUi=onUi; this.onChange=()=>{}}
  add(q){this.quests.push(q); this.onUi?.(); this.onChange?.()}
  mark(id,pred){const q=this.quests.find(q=>q.id===id); if(!q) return; const changed=q.progress(pred); if(changed){this.onUi?.(); this.onChange?.()}}
  allDone(){return this.quests.length>0 && this.quests.every(q=>q.done)}
}

/* ===========================
   Music (WebAudio)
=========================== */
function makeMusic(){
  const Music = {}
  let ac, master, running=false
  function init(){ if(ac) return; ac=new (window.AudioContext||window.webkitAudioContext)(); master=ac.createGain(); master.gain.value=0.1; master.connect(ac.destination) }
  function note(freq,len=0.25,type='sine',gain=0.2,attack=0.01,release=0.2, t=ac.currentTime){
    const o=ac.createOscillator(), g=ac.createGain(); o.type=type; o.frequency.value=freq
    g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(gain,t+attack); g.gain.linearRampToValueAtTime(0,t+len+release)
    o.connect(g).connect(master); o.start(t); o.stop(t+len+release)
  }
  function seq(){
    if(!running) return
    const t0=ac.currentTime
    const base=110, scale=[0,3,5,7,10,12].map(s=>base*Math.pow(2,s/12))
    for(let i=0;i<8;i++){ note(scale[i%scale.length]/2,0.35,'sawtooth',0.07,0.01,0.2,t0+i*0.5) }
    for(let i=0;i<4;i++){ const f=scale[(i*2)%scale.length]; note(f*2,1.8,'triangle',0.05,0.5,1.2,t0+i*1) }
    for(let i=0;i<16;i++){ const f=scale[(i*3)%scale.length]*4; note(f,0.12,'square',0.03,0.01,0.08,t0+i*0.25) }
    setTimeout(seq, 4000)
  }
  Music.toggle=async ()=>{
    if(!ac) init()
    if(ac.state==='suspended') await ac.resume()
    running=!running
    if(running) seq()
    return running
  }
  return Music
}

/* ===========================
   Game Director
=========================== */
class Game{
  constructor(canvas){
    this.engine=new Engine(canvas); this.g=this.engine.g
    this.seed=String(Date.now()); this.rng=sfc32(...hashStrToSeed(this.seed+'game'))
    this.map=new IsoMap(32,32,this.seed); this.map.generate(); this.factory=this.map.factory
    this.sprites=makeSpriteFactory()
    this.entities=[]
    this.player=new Player(4,4,this.sprites); this.entities.push(this.player)
    this.ui={quests:document.getElementById('quests'), ql:document.getElementById('ql'), hp:document.getElementById('hp'), toasts:document.getElementById('toasts'),
      flash:document.getElementById('flash'), overLose:document.getElementById('overlayGameOver'), overWin:document.getElementById('overlayWin'), musicBtn:document.getElementById('music')}
    this.quest=new QuestManager(()=>this.refreshQuestUi()); this.quest.onChange=()=>this.checkVictory()
    this.events={}
    this.labels=[]
    this.mouseIso={x:0,y:0}
    this.gameOver=false; this.victory=false
    this.music=makeMusic(); this.musicArmed=false

    this._buildWorld()
    this._placeCollectiblesGuaranteed(5)  // ensure all are reachable from spawn
    this._wireInput()
    this._mount()

    this.ui.overWin.classList.add('hidden'); this.ui.overLose.classList.add('hidden')
  }
  start(){ this.engine.start() }

  /* Build world fixtures within structures */
  _buildWorld(){
    // NPC & terminal in a far building
    const chiefPos=this._findFloorNear(26,16,6)
    const termPos=this._findFloorNear(26,18,6)
    this.chief=new NPC('Harbor Chief', chiefPos.x, chiefPos.y, [
      "Wind shear's lively today.",
      "Green conduits will carry you—if you let them.",
      "Cargo moves ideas as much as mass here."
    ])
    this.entities.push(this.chief)
    this.term=new Terminal('beacon', termPos.x, termPos.y, (game)=>{game.toast('Beacon harmonics stabilized.','accent'); game.onTerminal('beacon')})
    this.entities.push(this.term)

    // Puzzle plates in a lab wing; brass gate in the corridor
    const gatePos=this._findFloorNear(15,8,8)
    this.gate=new Gate('GateA', gatePos.x, gatePos.y, false); this.entities.push(this.gate)
    const plates=[
      this._findFloorNear(gatePos.x-2, gatePos.y+1, 8),
      this._findFloorNear(gatePos.x, gatePos.y+2, 8),
      this._findFloorNear(gatePos.x+2, gatePos.y+1, 8)
    ]
    this.switches=plates.map((p,i)=>new SwitchPlate('S'+i,p.x,p.y,()=>this.onSwitch()))
    this.switches.forEach(s=>this.entities.push(s))

    // Crates as obstacles sprinkled
    for(let i=0;i<12;i++){
      const p=this._findRandomFloor()
      if(dist(p.x,p.y,this.player.x,this.player.y)>4) this.entities.push(new Crate(p.x,p.y))
    }

    // Drones (enemies) roam halls
    this.targetDrones=3
    for(let i=0;i<this.targetDrones;i++){
      const p=this._findRandomFloor()
      this.entities.push(new Drone(p.x,p.y,this.sprites))
    }

    // Reveal start
    this.map.reveal(this.player.x|0,this.player.y|0,5)

    // Quests
    this.quest.add(new Quest('story','First Assignment','story',[
      {id:'reach',text:'Find the Harbor Chief on the east ring'},
      {id:'handoff',text:'Deliver the micro‑core (interact)'},
      {id:'beacon',text:'Energize the signal beacon'}
    ]))
    this.quest.add(new Quest('puzzle','Harmonic Locks','puzzle',[
      {id:'pa',text:'Set plate A'},{id:'pb',text:'Set plate B'},{id:'pc',text:'Set plate C'},{id:'open',text:'Open the brass gate'}
    ]))
    this.quest.add(new Quest('combat','Wayward Sentinels','combat',[
      {id:'d1',text:'Disable 1/3 drones'},{id:'d2',text:'Disable 2/3 drones'},{id:'d3',text:'Disable 3/3 drones'}
    ]))
    this.quest.add(new Quest('explore','Chart the Concourse','exploration',[{id:'disc',text:'Reveal 75% of the ring'}]))
    this.quest.add(new Quest('collect','Spare Capacitors','collection',[
      {id:'s1',text:'Collect 1/5 shards'},{id:'s2',text:'Collect 2/5 shards'},{id:'s3',text:'Collect 3/5 shards'},{id:'s4',text:'Collect 4/5 shards'},{id:'s5',text:'Collect 5/5 shards'}
    ]))
  }

  /* Floor helpers */
  _findRandomFloor(){
    for(let tries=0; tries<200; tries++){
      const x=(this.rng()*this.map.w)|0, y=(this.rng()*this.map.h)|0
      const t=this.map.at(x,y); if(t && t.walkable && t.type!=='wall') return {x,y}
    } return {x:4,y:4}
  }
  _findFloorNear(x0,y0,r){
    let best={x:x0,y:y0}, bd=1e9
    for(let y=Math.max(1,y0-r);y<=Math.min(this.map.h-2,y0+r);y++){
      for(let x=Math.max(1,x0-r);x<=Math.min(this.map.w-2,x0+r);x++){
        const t=this.map.at(x,y)
        if(t.walkable && t.type!=='wall'){
          const d=(x-x0)*(x-x0)+(y-y0)*(y-y0)
          if(d<bd){bd=d; best={x,y}}
        }
      }
    }
    return best
  }

  /* Guaranteed reachable collectibles (BFS from player) */
  _placeCollectiblesGuaranteed(n){
    const visited=new Set(), q=[[this.player.x|0,this.player.y|0]]
    visited.add(`${this.player.x|0},${this.player.y|0}`)
    const reachable=[]
    while(q.length){
      const [x,y]=q.shift(); const t=this.map.at(x,y)
      if(t?.walkable) reachable.push({x,y})
      for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx=x+dx, ny=y+dy
        if(!this.map.inBounds(nx,ny)) continue
        const key=`${nx},${ny}`; if(visited.has(key)) continue
        const tt=this.map.at(nx,ny)
        if(tt.walkable && !(nx===this.gate.x && ny===this.gate.y && !this.gate.open)){
          visited.add(key); q.push([nx,ny])
        }
      }
    }
    // sample distinct tiles far enough from player
    const chosen=[]; const minDist=6
    for(let i=0;i<reachable.length && chosen.length<n;i++){
      const p=reachable[(i*37)%reachable.length]
      if(dist(p.x,p.y,this.player.x,this.player.y)>=minDist && !chosen.some(c=>c.x===p.x&&c.y===p.y)) chosen.push(p)
    }
    // If still short, just fill from tail
    while(chosen.length<n && reachable.length){ const p=reachable.pop(); if(!chosen.some(c=>c.x===p.x&&c.y===p.y)) chosen.push(p) }
    // Place
    this.pickups=[]
    chosen.slice(0,n).forEach(p=>{const item=new Pickup('shard',p.x,p.y,this.sprites); this.pickups.push(item); this.entities.push(item)})
  }

  _wireInput(){
    addEventListener('keydown',e=>{
      if(!this.musicArmed){ this.musicArmed=true }
      if(e.code==='KeyE') this.interact()
      else if(e.code==='KeyQ') this.ui.ql.classList.toggle('hidden')
      else if(e.code==='KeyM') this.toggleMusic()
    })
    addEventListener('click',()=>{ if(!this.musicArmed){ this.musicArmed=true } })
    this.ui.musicBtn.addEventListener('click',()=>this.toggleMusic())

    // MOUSE ↔ TILE ALIGNMENT: account for CSS scaling
    this.engine.c.addEventListener('mousemove', e=>{
      const rect=this.engine.c.getBoundingClientRect()
      const scaleX=this.engine.c.width/rect.width
      const scaleY=this.engine.c.height/rect.height
      const mx=(e.clientX-rect.left)*scaleX
      const my=(e.clientY-rect.top)*scaleY
      const sx=mx + this.engine.cam.x
      const sy=my + this.engine.cam.y
      this.mouseIso=screenToIso(sx,sy)
    })

    document.getElementById('btnRetry').addEventListener('click',()=>location.reload())
    document.getElementById('btnPlayAgain').addEventListener('click',()=>location.reload())

    this.events.onMove=(pl)=>{
      if(dist(pl.x,pl.y,this.chief.x,this.chief.y)<2) this.quest.mark('story',o=>o.id==='reach')
      const revealed=this.map.discovered.reduce((a,b)=>a+b,0), total=this.map.w*this.map.h
      if(revealed/total>=0.75) this.quest.mark('explore',o=>o.id==='disc')
    }
  }
  async toggleMusic(){
    const on = await this.music.toggle()
    this.ui.musicBtn.textContent = on ? 'Music: On' : 'Music: Off'
  }

  _mount(){
    this.engine.updatables.push({update:(dt)=>this.update(dt)})
    this.engine.renderables.push({render:(g)=>this.render(g)})
  }

  /* Collision system */
  isBlockedTile(ix,iy){if(!this.map.inBounds(ix,iy)) return true; const t=this.map.at(ix,iy); return !t?.walkable}
  resolveCollisions(ent, nx, ny, ignorePlayer=false){
    let x=nx, y=ny
    const r=ent.r
    const minX=Math.floor(x-r-1), maxX=Math.ceil(x+r+1)
    const minY=Math.floor(y-r-1), maxY=Math.ceil(y+r+1)
    function collideAABB(cx,cy, tx,ty){
      const half=0.5
      const closestX=clamp(cx, tx-half, tx+half)
      const closestY=clamp(cy, ty-half, ty+half)
      const dx=cx-closestX, dy=cy-closestY
      return dx*dx+dy*dy < r*r
    }
    // Tiles & closed gate
    for(let ty=minY; ty<=maxY; ty++){
      for(let tx=minX; tx<=maxX; tx++){
        const gateBlock = (!this.gate.open && tx===this.gate.x && ty===this.gate.y)
        if(this.isBlockedTile(tx,ty) || gateBlock){
          if(collideAABB(x,y,tx,ty)){
            const dx=x - clamp(x,tx-0.5,tx+0.5)
            const dy=y - clamp(y,ty-0.5,ty+0.5)
            if(Math.abs(dx)>Math.abs(dy)){
              x = dx>0 ? (tx+0.5)+r : (tx-0.5)-r
            }else{
              y = dy>0 ? (ty+0.5)+r : (ty-0.5)-r
            }
          }
        }
      }
    }
    // Solid objects
    for(const o of this.entities){
      if(o===ent) continue
      if(o.solid && !o.dead){
        const d=dist(x,y,o.x,o.y), rr=r+o.r
        if(d<rr){
          const nx1=(x-o.x)/ (d||1), ny1=(y-o.y)/(d||1)
          const push=rr - d
          x += nx1*push; y += ny1*push
        }
      }
    }
    // Entity separation
    for(const o of this.entities){
      if(o===ent) continue
      if(o.kind!=='pickup' && !o.dead){
        const d=dist(x,y,o.x,o.y), rr=r+o.r
        if(d<rr){
          const nx1=(x-o.x)/ (d||1), ny1=(y-o.y)/(d||1)
          const push=rr - d
          if(o.kind==='player' && ignorePlayer) continue
          x += nx1*(push*0.7)
        }
      }
    }
    return {x,y}
  }

  /* Rules */
  interact(){
    let best=null, bd=999
    for(const e of this.entities){
      if(['npc','terminal','switch','pickup','gate'].includes(e.kind)){
        const d=dist(this.player.x,this.player.y,e.x,e.y)
        if(d<1.4 && d<bd){best=e; bd=d}
      }
    }
    if(!best){this.toast('Nothing to interact with.'); return}
    if(best.kind==='npc'){
      best.talk(this)
      if(best===this.chief && this.player.inv.core){
        this.player.inv.core=false
        this.toast('Micro‑core delivered.','accent')
        this.fxLabel(best,'Thank you.','#b2ffd8')
        this.quest.mark('story',o=>o.id==='handoff')
      }
    }else if(best.kind==='terminal'){
      best.onUse?.(this)
    }else if(best.kind==='switch'){
      best.interact(this)
      const idx=this.switches.indexOf(best); const ids=['pa','pb','pc']; if(idx>=0) this.quest.mark('puzzle',o=>o.id===ids[idx])
    }else if(best.kind==='pickup'){
      this.entities.splice(this.entities.indexOf(best),1); this.pickups.splice(this.pickups.indexOf(best),1)
      const n=++this.player.inv.shards; this.toast(`Capacitor shard ${n}/5`, 'accent')
      const ids=['s1','s2','s3','s4','s5']; this.quest.mark('collect',o=>o.id===ids[Math.min(n-1,4)])
    }else if(best.kind==='gate'){
      this.toast(this.gate.open?'Gate open.':'Gate sealed—calibrate plates.')
    }
  }
  onTerminal(id){ if(id==='beacon'){ this.quest.mark('story',o=>o.id==='beacon'); this.fxLabel(this.term,'BEACON ONLINE','#39ffb8') } }
  onEnemyDown(e){
    this.toast('Drone disabled.','warn')
    const q=this.quest.quests.find(q=>q.id==='combat'); if(!q) return
    const next=q.objectives.find(o=>!o.done); if(next) this.quest.mark('combat',o=>o.id===next.id)
  }
  onSwitch(){
    const all = this.switches.every(s=>s.on===1)
    if(all){ this.gate.setOpen(true); this.fxLabel(this.gate,'GATE OPEN','#ffd45e'); this.quest.mark('puzzle',o=>o.id==='open') }
  }
  damagePlayer(amount, source){
    if(this.gameOver||this.victory) return
    this.player.hp = Math.max(0, this.player.hp - amount)
    document.getElementById('hp').textContent=this.player.hp
    this.ui.flash.style.opacity='1'; setTimeout(()=>this.ui.flash.style.opacity='0',120)
    this.fxLabel(this.player, `-${amount}`, '#ff7373')
    if(source){ const dx=this.player.x - source.x, dy=this.player.y - source.y; const L=Math.hypot(dx,dy)||1; const k=0.25; const nx=this.player.x + (dx/L)*k, ny=this.player.y + (dy/L)*k
      const res=this.resolveCollisions(this.player, nx, ny); this.player.x=res.x; this.player.y=res.y }
    if(this.player.hp<=0) this.triggerGameOver()
  }

  checkVictory(){ if(this.quest.allDone() && !this.victory && !this.gameOver){ this.victory=true; this.engine.stop(); this.ui.overWin.classList.remove('hidden') } }
  triggerGameOver(){ if(this.gameOver||this.victory) return; this.gameOver=true; this.engine.stop(); this.ui.overLose.classList.remove('hidden') }

  fxLabel(ent,text,color='#cdeef0'){const s=ent.iso(); this.labels.push({x:s.x,y:s.y-28,a:1,t:0,life:1.2,text,color})}
  toast(msg,cls){const t=document.createElement('div'); t.className='toast'+(cls?(' '+cls):''); t.textContent=msg; this.ui.toasts.appendChild(t); setTimeout(()=>t.remove(),2000)}
  refreshQuestUi(){
    const wrap=this.ui.quests; wrap.innerHTML=''
    for(const q of this.quest.quests){
      const box=document.createElement('div'); box.className='quest'
      const h=document.createElement('h3'); h.textContent=q.title; const tag=document.createElement('span'); tag.className='tag'; tag.textContent=q.type; h.appendChild(tag); box.appendChild(h)
      for(const o of q.objectives){const p=document.createElement('div'); p.className='q-obj'+(o.done?' q-done':''); p.textContent=o.text; box.appendChild(p)}
      wrap.appendChild(box)
    }
  }

  update(dt){
    if(this.gameOver||this.victory) return
    for(const e of this.entities){ e.update?.(dt,this) }
    for(const L of this.labels){ L.t+=dt; L.y-=14*dt; L.a = 1 - (L.t/L.life) }
    this.labels = this.labels.filter(L=>L.t<L.life)
    const ps=this.player.iso(); this.engine.cam.centerOn(ps.x,ps.y,this.engine.c.width,this.engine.c.height)
  }
  render(g){
    const cam=this.engine.cam
    g.save(); g.translate(-cam.x, -cam.y)
    // Ground tiles
    for(let y=0;y<this.map.h;y++)for(let x=0;x<this.map.w;x++){
      const t=this.map.at(x,y), s=isoToScreen(x,y,0)
      const pat=this.factory.faces[t.type] || this.factory.faces.steel
      this.factory.drawDiamond(g,s.x,s.y,t.height?8:0,pat)
      if(!this.map.isDiscovered(x,y)){g.fillStyle='rgba(6,10,14,0.65)'; g.beginPath(); g.moveTo(s.x,s.y); g.lineTo(s.x+TILE_W/2,s.y+TILE_H/2); g.lineTo(s.x,s.y+TILE_H); g.lineTo(s.x-TILE_W/2,s.y+TILE_H/2); g.closePath(); g.fill()}
    }
    // Entities sorted by iso depth
    const ents=[...this.entities].sort((a,b)=>(a.x+a.y)-(b.x+b.y))
    for(const e of ents){ if(this.map.isDiscovered(e.x|0,e.y|0)) e.render(g,this.engine) }
    // Labels
    for(const L of this.labels){ g.globalAlpha=L.a; g.fillStyle='#0b0b0b'; g.fillRect(L.x-40,L.y-10,80,16); g.strokeStyle='rgba(255,255,255,.12)'; g.strokeRect(L.x-40,L.y-10,80,16);
      g.fillStyle=L.color; g.textAlign='center'; g.textBaseline='middle'; g.font='12px monospace'; g.fillText(L.text,L.x,L.y); g.globalAlpha=1 }
    // Mouse tile highlight (aligned)
    const hx=Math.round(this.mouseIso.x), hy=Math.round(this.mouseIso.y)
    if(this.map.inBounds(hx,hy)){ const s=isoToScreen(hx,hy,0); g.strokeStyle='rgba(57,255,184,.7)'; g.beginPath(); g.moveTo(s.x,s.y); g.lineTo(s.x+TILE_W/2,s.y+TILE_H/2); g.lineTo(s.x,s.y+TILE_H); g.lineTo(s.x-TILE_W/2,s.y+TILE_H/2); g.closePath(); g.stroke() }
    g.restore()
  }
}

/* ===========================
   Bootstrap (fit & start)
=========================== */
(function(){
  const canvas=document.getElementById('c')
  function fit(){const w=innerWidth, h=innerHeight-50; const s=Math.min(w/1280,h/720); canvas.style.width=(1280*s)+'px'; canvas.style.height=(720*s)+'px'}
  addEventListener('resize',fit); fit()
  const game=new Game(canvas); window.__game=game
  game.refreshQuestUi()
  document.getElementById('hp').textContent=game.player.hp
  game.start()
})();
</script>
</body>
</html>
